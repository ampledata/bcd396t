December 5, 2011

Followed instructions in github setup to create initial repo including for this instruction manual.

rob@wrath:~/bcd396t$ git init
Initialized empty Git repository in /home/rob/bcd396t/.git/
rob@wrath:~/bcd396t$   touch README
rob@wrath:~/bcd396t$   git add README
rob@wrath:~/bcd396t$   git commit -m 'first commit'
[master (root-commit) 7c1bbee] first commit
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 README
rob@wrath:~/bcd396t$   git remote add origin git@github.com:vees/bcd396t.git
rob@wrath:~/bcd396t$   git push -u origin master
Counting objects: 3, done.
Writing objects: 100% (3/3), 204 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To git@github.com:vees/bcd396t.git
 * [new branch]      master -> master
Branch master set up to track remote branch master from origin.


First step is to acquire more information about any other applications, libraries, API, or control code that might already do what I want.

Found a library called hamlib that says it has a link to Python.

The spec sheet for the Uniden BCD-396T is model #810, located at:

http://hamlib.sourceforge.net/sup-info/support/model810.txt

Overall backend warnings: 0



Found the following code in hamlib repository:

http://hamlib.git.sourceforge.net/git/gitweb.cgi?p=hamlib/hamlib;a=blob;f=uniden/uniden_digital.c;h=e42939f7efb49e2a79b8a30e34a3899a000d604b;hb=HEAD

Thread in radioreference:

http://forums.radioreference.com/scanner-programming-software/39530-new-radios-old-problem-no-solution.html

http://forums.radioreference.com/uniden-scanners/162214-bcd996xt-software-rs232-control-protocols.html



Got minicom working on /dev/ttyUSB0 and sent a few commands:

STS,011000,                ,,Baltimore County,,N     ID SCA �  ,, 859.9625       ,,S0:1*****-*--   ,,GRP1*****78*-   ,,1,1,0,0
STS,011000,          ��    ,,Baltimore County,,  ID SCAN    �  ,, 859.9625       ,,S0:1*****-*--   ,,GRP1*****78*-   ,,1,1,0,0
STS,011000,                ,,Baltimore County,,D SCAN     I �  ,, 859.9625       ,,S0:-*****-*--   ,,GRP1*****78*-   ,,1,1,0,0
STS,011000,                ,,Fire Dispatch   ,,Western Fire 4  ,, 858.9625       ,,S0:-*****-*--   ,,GRP1*****-8*-   ,,1,1,0,0
GID,,,,,,


Using manual file downloaded from:

http://www.scannerdesk.com/joomla/files/uniden/396T/BCD396T_Protocol.pdf


December 6, 2011

Found pyserial:

http://pyserial.sourceforge.net/pyserial_api.html

rob@diligence:~$ python -i serinit.py
>>> ser
Serial<id=0xb787d8ec, open=True>(port='/dev/ttyUSB0', baudrate=115200, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=0, rtscts=0, dsrdtr=0)
>>> ser.isWaiting()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Serial' object has no attribute 'isWaiting'
>>> ser.inWaiting()
0
>>> ser.write("STS\n\r")
>>> ser
Serial<id=0xb787d8ec, open=True>(port='/dev/ttyUSB0', baudrate=115200, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=0, rtscts=0, dsrdtr=0)
>>> ser.inWaiting()
4
>>> ser.read(4)
'ERR\r'
>>> ser.write("STS\r")
>>> ser.inWaiting()
127
>>> ser.read(127)
'STS,011000,          \xac\xad    ,,Baltimore County,,SCAN     ID  \x82  ,, 860.9625       ,,S0:-*****-*--   ,,GRP1*****78*-   ,,1,1,0,0\r'
>>> ser.inWaiting()
0
>>> ser.write("STS\r")
>>> ser.read(ser.inWaiting())
'STS,011000,          \xac\xad    ,,Baltimore County,,Eastern Fire 3  ,, 858.9625       ,,S0:1*****-*--   ,,GRP1*****78*-   ,,1,0,0,0\r'
>>> ser.write("STS\r")
>>> ser.read(ser.inWaiting())
'STS,011000,          \xac\xad    ,,Baltimore County,,Central Fire 2  ,, 858.2125       ,,S0:-*****-*--   ,,GRP1*****-8*-   ,,1,0,0,0\r'
>>> ser.write("GLG\r")
>>> ser.read(ser.inWaiting())
'GLG,80,NFM,0,0,Baltimore County,Fire Dispatch,Eastern Fire 3,1,0\r'
>>> 



Channel list activate/deactivate:

PRG                                                                                              
PRG,OK                                                                                           
QSL
QSL,1222220200,0000000000,0000000000,0000000000,0000000000,0000000000,0000000000,0000000000,0000000000,0000000000
QGL,1
QGL,ERR
SIH
SIH,5285
QSL,PAGE0
QSL,ERR
QSL,0
QSL,ERR
QSL
QSL,1222220200,0000000000,0000000000,0000000000,0000000000,0000000000,0000000000,0000000000,0000000000,0000000000
SIN,5285
SIN,M82S,Baltimore County,1,2,0,2,,AUTO,0,AUTO,8,-1,5166,5287,5287,4
QSL,5285
QSL,ERR
QGL,5285
QGL,1122221120
QGL,5285,1222221220
QGL,OK
EPG
EPG,OK
KEY,S,P
KEY,OK
SYS
ERR
STS
STS,011000,          ��    ,,Baltimore County,,Eastern Fire 3  ,, 860.4625       ,,S0:1*****-*--   ,,GRP1*****7**-   ,,1,0,0,0



Ben suggested using shared queues for the client and server to exchange information about which quick groups to activate instead of exposing a secured API to the public.

If we build the security all on the server side then there's little work left to be done on the client, for example:

1. Client contacts the server and provides a list of all the channels that are available on the scanner and their state. Server saves these channels locally for use between contacts with the client.

2. The server can display a list of the available channels to users that show up and which ones are active since the last communication from the server.

3. Users on the server select and vote and the server makes all the decisions about which channels should be selected.

4. The client contacts the server again on schedule and downloads a list of the channels the server believes should be active.

5. The client compares this list against a current list of active channels and sets a new QGL if one is necessary.

6. Client repeats from the step 1.



A good exercise will be to run this client/server setup using the quick groups in bank 1.  There are 9 slots, so if both client and server version 0 know this, it's easy to exchange the information.

Send to server:

PRG
PRG,OK
QGL,5285
QGL,1122221120
EPG
EPG,OK
KEY,S,P
KEY,OK

We always want to return to scanning at the end of a program transaction.

Client saves: 1122221120
Server saves: 1122221120

Server makes changes, decides to send packet back with all channels enabled as 1111111110:

Server sends: 1111111110
Client compares 1111111110 to 1122221120

Client sees a difference, calls:

PRG
PRG,OK
QGL,5285,1111111110
QGL,OK
QGL,5285
QGL,1111111110
EPG
EPG,OK
KEY,S,P
KEY,OK

Client sends: 1111111110 (confirmation)
Client saves: 1111111110
Server saves: 1111111110

Now every quick group available are selected, and we're back to scanning.



Assuming this happens only when the server has decided that enough has changed, the radio should only go into program mode once every few minutes at the most, and it can always wait for a break in the action by doing a GID for no channel in order to not interrupt an active transmission. This is better than trying to toggle buttons on the keypad by taking the output of STS and going KEY inputs of the group codes.



The only thing the radio and the server need to share are the QGL's ID of 5285.

December 7, 2011

[singapore]$ sqlite3 bcd396t.db
SQLite version 3.7.3
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite> create table quicklist(quickgroup int unique, requested datetime);
sqlite> select * from quicklist;
sqlite> insert into quicklist values (1,'2011-12-7 22:32');
sqlite> insert into quicklist values (2,'2011-12-7 22:32');
sqlite> insert into quicklist values (3,'2011-12-7 22:32');
sqlite> insert into quicklist values (4,'2011-12-7 22:32');
sqlite> insert into quicklist values (5,'2011-12-7 22:32');
sqlite> insert into quicklist values (6,'2011-12-7 22:32');
sqlite> insert into quicklist values (7,'2011-12-7 22:32');
sqlite> insert into quicklist values (8,'2011-12-7 22:32');
sqlite> insert into quicklist values (9,'2011-12-7 22:32');
sqlite> select * from quicklist;
1|2011-12-7 22:32
2|2011-12-7 22:32
3|2011-12-7 22:32
4|2011-12-7 22:32
5|2011-12-7 22:32
6|2011-12-7 22:32
7|2011-12-7 22:32
8|2011-12-7 22:32
9|2011-12-7 22:32
sqlite> 

sqlite> create table display(linenumber int unique, linetext varchar(512));
sqlite> insert into display values (1,'');

create table quicklist(quickgroup int unique, requested datetime);
select * from quicklist;
insert into quicklist values (1,'2011-12-7 22:32');
insert into quicklist values (2,'2011-12-7 22:32');
insert into quicklist values (3,'2011-12-7 22:32');
insert into quicklist values (4,'2011-12-7 22:32');
insert into quicklist values (5,'2011-12-7 22:32');
insert into quicklist values (6,'2011-12-7 22:32');
insert into quicklist values (7,'2011-12-7 22:32');
insert into quicklist values (8,'2011-12-7 22:32');
insert into quicklist values (9,'2011-12-7 22:32');

[singapore]$ ls
bcd396t.sqlite	index.php
[singapore]$ git remote add origin git@github.com:vees/bcd396t.git/server

qlite> create table display (posted datetime primary key asc, statustext varchar(512))
   ...> ;

create table votes(quickgroup int, vote int, posted datetime, ipaddr varchar(16));

select quickgroup,vote,count(vote) from votes group by quickgroup,vote order by quickgroup,vote;

